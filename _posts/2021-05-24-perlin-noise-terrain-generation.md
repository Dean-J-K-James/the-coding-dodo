---
title: Perlin Noise Terrain Generation
category: Algorithms
tags: Terrain Noise
---

Explore how to generate 2D height maps using both static and Perlin noise. Then use these to create infinite, continental terrain on a 2D tilemap.

## What is Noise?

In computer science, noise is a set of procedurally generated numbers, usually generated for, and stored in, a two dimensional grid. A grid made up of individual noise values is known as a noise map. There are several types of noise, each with unique properties and purposes. Some are entirely random, such as static noise, and some are generated according to an algorithm, such as perlin noise.

Noise values range between 0 and 1. This allows them to  be linearly interpolated into a greyscale colour, where they can be rendered to a texture like in *Figure 1*.

![Example Noise Samples](/assets/images{{ page.url}}/figure1.png)

> **Figure 1** - Example static noise on a greyscale texture.

When each noise value (a decimal between 0 and 1) is linearly interpolated to between 0 and 255, they represent one of the 256 shades of grey

* A noise value of 0.0 would generate an rgb value of `rgb(000, 000, 000)`.
* A noise value of 1.0 would generate an rgb value of `rgb(255, 255, 255)`.
* A noise value of 0.5 would generate an rgb value of `rgb(128, 128, 128)`.

Linear interpolation can be achieved using the following function.

    function lerp(a, b, v) {
        return (1 - v) * a + v * b;
    }

The parameters, `a` and `b` , represent the minimum and maximum respectively (in this case 0 and 255), and `v` represents the value that needs interpolating (in this case, the noise value). 

<div class="tip">The implementation and rendering of a grid is not shown in this tutorial, but many tutorials exist for creating tilemaps in various languages and engines.</div>

## Static Noise

Perhaps the most common example of noise is static noise (also called white noise), where each noise value is an unrelated, random number. Generating static noise is quite simple. Loop each coordinate in a grid, and assign it a random value between 0 and 1.

    function generate_static() {
        for (var x = 0; x < sizex; x++) {
            for (var y = 0; y < sizey; y++) {
                noise[x][y] = Math.random();
            }
        }
    }

*Figure 1* visualises a static noise map.

## Perlin Noise?

Static noise is entirely random. Whilst this has its uses, it is not appropriate for generating the continental style terrain that we want. Instead, perlin noise can be used. Perlin noise is deterministically generated by an algorithm, creating a smooth, gradient based noise map, like in *Figure 2*. You can clearly see it follows a pattern, producing waves.

![Perlin Noise](/assets/images{{ page.url}}/figure2.png)

> **Figure 2** - Example perlin noise on a greyscale texture.

Generating a noise map using perlin noise is very similar to generating a static noise map. Instead of creating a random number between 0 and 1, we call a function, `perlinNoise` , passing the `x` and `y` position.

    function generate_perlin() {
        for (var x = 0; x < sizex; x++) {
            for (var y = 0; y < sizey; y++) {
                noise[x][y] = perlinNoise(x * scale, y * scale);
            }
        }
    }

For each coordinate, we multiply the `x` and `y` by a variable, `scale`. This is used to adjust the "zoom" of our perlin noise map. By default, we use a value of 0.1 for `scale`.

![Perlin Noise With Different Scale](/assets/images{{ page.url}}/figure3.png)

> **Figure 3** - A perlin noise map with scale 0.2.

The image in *Figure 3* shows the same noise map as *Figure 2*, except with a scale of 0.2 instead of 0.1. A larger scale value creates noise maps that appear more "zoomed" out.

<div class="tip">The perlin noise function itself will not be manually written for this tutorial, because there are lots of implementations for it in different languages and engines already (see end of page for some links). Replace `perlinNoise` with whatever implementation you use.</div>

## Using Perlin Noise as Terrain

So far, all noise we have covered has been rendered as a greyscale texture, where each noise value is converted to a shade of grey using linear interpolation. This looks nothing like terrain.

Instead of thinking of each noise value as noise, think of them as a height, or a density of terrain. Depending on the noise value, the cell becomes a different type of terrain. For example, any value below 0.5 gets classified as water, and any value above 0.5 gets classified as land, and so on...

![Static Noise as Terrain](/assets/images{{ page.url}}/figure4.png)

> **Figure 4** - Static noise map rendered by terrain type.

*Figure 4* shows a static noise map rendered as terrain. The following code shows the classifications that were used.

    set_cell_type(x, y, h) {
        //Deep Water
        if (h < 0.40)
            return this.set_cell(x, y, [21, 61, 181]);

        //Shallow Water
        if (h < 0.50)
            return this.set_cell(x, y, [81, 111, 241]);

        //Sand
        if (h < 0.6)
            return this.set_cell(x, y, [251, 211, 161]);

        //Grass
        if (h < 0.9)
            return this.set_cell(x, y, [31, 131, 31]);

        //Mountain
        if (h < 1.0)
            return this.set_cell(x, y, [51, 51, 51]);
    }

If the noise value is less than 0.40, then the cell is coloured a dark blue, if it is more than 0.40 and less than 0.50, then it is coloured light blue. The same classification of noise values when applied to a perlin noise map looks like *Figure 5*.

![Perlin Noise as Terrain](/assets/images{{ page.url}}/figure5.png)

> **Figure 5** - Perlin noise map rendered by terrain type.

This basic perlin noise creates a simple continental style terrain. The ranges for each terrain type can be adjusted to get more or less water, rock, grass, and more... Overall, the noise map generated by perlin noise so far is quite simple, and a bit too smooth. Fortunately, there are various methods to improve the terrain, making it more detailed and realistic.

## Adding Detail Using Octaves

To improve the look of our terrain, we are going to generate the height of each cell several times, each with a different scale value. These noise values will then be stacked, and normalised. This will make the terrain more rough and organic. The function `genarate_terrain` generates more detailed and realistic noise values for each coordinate using octaves.

    generate_terrain() {
        let max_n = 0;
        let min_n = 9;

        for (let x = 0; x < this.sizex; x++)
            for (let y = 0; y < this.sizey; y++) {

                let scale = 0.05;
                let value = 0.00;

                for (let octave = 1; octave <= 4; octave++) {
                    let ox = x * (scale * octave);
                    let oy = y * (scale * octave);

                    value += (this.perlin_noise(ox, oy)) * (1 / (octave + 1));
                }

                this.grid[x][y] = value;

                max_n = Math.max(max_n, value);
                min_n = Math.min(min_n, value);
            }

        this.normalise_and_apply_terrain(min_n, max_n);
    }

For each coordinate in the map, we produce noise for different scale values. The variable `octave` represents the current octave we are on. On each octave, we generate the x and y value, denoted by the variables, `ox` and `oy` . Instead of just multiplying them by the scale, we multiply them by the scale and the octave. This modifies the scale for each octave, zooming in and out the sampled noise map.

For each of the four octaves, the scale value is:

1. `scale = 0.05` and `octave = 1` results in `x * 0.05`
2. `scale = 0.05` and `octave = 2` results in `x * 0.10`
3. `scale = 0.05` and `octave = 3` results in `x * 0.15`
4. `scale = 0.05` and `octave = 4` results in `x * 0.20`

On each octave, the scale value we use increases, resulting in a more zoomed out sample. These then get added to a total noise `value` for that cell. When the octaves have finished, the noise value at `grid[x][y]` is set to the total of all values for each octave.

Secondly, we also multiply the returned perlin value in the following formula: `(perlinNoise(ox, oy)) * (1 / (octave + 1))` . This reduces the strength of the noise value for each subsequent octave, meaning the more detailed values have less effect than the initial value.

## Clamping the Values

Since we are adding multiple noise values together, the noise value for a single coordinate will no longer be in the range 0 to 1. To bring the values back within this range, we have to use the inverse of a linear interpolation. First though, we need to record the minimum and maximum noise values used.

Each time we finish calculating the noise value for a coordinate, we check it against the current minimum and maximum, updating those if needed. In the `generate_terrain` function, `max_n` represents the max noise value on the noise map, and `min_n` represents the minimum noise value. Every time we store a new noise value in the array, we update `max_n` and `min_n` to ensure they keep track of the bounds.

Once the noise value of each coordinate is set, we have to normalise them so that they all fall between the values 0 and 1. The function, `normalise_and_apply_terrain` is used for that.

    normalise_and_apply_terrain(min_n, max_n) {
        for (let x = 0; x < this.sizex; x++) {
            for (let y = 0; y < this.sizey; y++) {
                this.set_cell_type(x, y, inverse_lerp(min_n, max_n, this.grid[x][y]));
            }
        }
    }

For each coordinate, we call the `set_cell_type` function. This takes an x and y coordinate, along with a height which is uses to determine the terrain type. The height we pass is the value returned by the `inverse_lerp` function.

    function inverse_lerp(a, b, v) {
        return clamp(0, 1, (v - a) / (b - a));
    }

    function clamp(min, max, v) {
        return Math.min(Math.max(v, min), max);
    }

Once we have applied the octaves and normalised the terrain, we generate something like in *Figure 6*.

![Perlin Noise Terrain With Octaves](/assets/images{{ page.url}}/figure6.png)
> **Figure 6** - Perlin noise terrain with several octaves applied.

In comparison to *Figure 5*, which has no octaves applied, *Figure 6* is far more detailed and organic, with less straight edges.

## Further Reading

* This YouTube playlist for Generating [Procedural Terrain](https://youtu.be/wbpMiKiSKm8) in Unity is detailed and visualised well.
* An article explaining [Terrain From Noise](https://www.redblobgames.com/maps/terrain-from-noise/), and some of the theory behind it.
